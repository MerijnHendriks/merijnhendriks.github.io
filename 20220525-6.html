<!DOCTYPE html><html lang="en"><head> <meta charset="utf-8"> <meta name="viewport" content="width=device-width,initial-scale=1"> <meta name="description" content="To me, object-oriented programming is a bit weird. It's like trying to make many..."> <meta name="author" content="Merijn Hendriks"> <link rel="icon" type="image/x-icon" href="./assets/img/favicon.ico"> <link rel="stylesheet" type="text/css" href="./assets/css/bundle.css"> <title>OOP: Thoughts</title></head> <body> <div class="container-fluid min-vh-100 d-flex flex-column"> <div class="p-5 blog-banner"> <div class="container-fluid py-5"> <h1 class="display-5 fw-bold"><a href="./index.html">Merijn Hendriks</a></h1> <p class="col-md-8 fs-4">Programmer, Creative, Nerd</p> </div> </div> <div class="row flex-grow-1"> <div class="col-md-8 p-5" id="blog-content"><h1>OOP: Thoughts</h1> <p>To me, object-oriented programming is a bit weird. It's like trying to make many small-contained programs in a big program, or to componentize your code to the extend it's becoming lego bricks; plug and play. It's a way of programming loved by enterprises and acedemia for the modularity, protections and standarization, as well as for all the open-ended debate and research that comes with new techniques and philosophies. On the other side, very important programmers like <code>Rob Pike</code>, <code>Paul Graham</code> and <code>John Carmack</code> advocate against the usage of object-oriented design:</p> <blockquote class="blockquote blog-blockquote px-3"> <p>"Object-oriented design is the roman numerals of computing." — Rob Pike</p> </blockquote> <blockquote class="blockquote blog-blockquote px-3"> <p>"The object-oriented model makes it easy to build up programs by accretion. What this often means, in practice, is that it provides a structured way to write spaghetti code." — Paul Graham</p> </blockquote> <blockquote class="blockquote blog-blockquote px-3"> <p>"Sometimes, the elegant implementation is just a function. Not a method. Not a class. Not a framework. Just a function." — John Carmack</p> </blockquote> <blockquote class="blockquote blog-blockquote px-3"> <p>"It is not that uncommon for the cost of an abstraction to outweigh the benefit it delivers. Kill one today!" — John Carmack</p> </blockquote> <h2>OOP considered harmful?</h2> <p>Because of all the standarization efforts, it's much easier for enterprises to look for programmers with a specific set of skills universally understood. This in theory means there are much more job oppertunities, but in pratice it means the programmers are now turned into robots glueing components together others wrote or written by yourself.</p> <p>Okay that's quite an overstatement, but there is truth to this; businesses like to play it safe, why write it yourself if someone else did it already? There are plenty of arguments to be made in opposition to this, but usually it's not appriciated. That's why these days I just try to avoid the discussion.</p> <p>I don't think that OOP is bad on it's own, there certainly are cases where OOP <em>is</em> the best solution. However, I believe that most programmers passionate about OOP go too deep into the doctrine of adhearing to principles and paradigms, making them blind to the complexity it brings with it.</p> <h2>Correctness</h2> <p>Something I discovered recently is that imperative program use tuning machines to prove mathmetical correctness of a program. Functional programs can use labda calculus. Event driven languages can use pi calculus. But what about OOP? So far there is no mathmetical model which can validate the mathmetical corectness of such a program, or at least not one agreed-upon solution that I am aware of.</p> <p>Instead, OOP relies on principles and paradigms like GRASP and SOLID to validate whenever your code is "correct":</p> <ul> <li>Favor composition over inheritance</li> <li>Hollywood Principle</li> <li>Program to an Interface, not to an Implementation</li> <li>GRASP <ul> <li>Creator</li> <li>Controller</li> <li>High Cohesion</li> <li>Indirection</li> <li>Information Expert</li> <li>Low Coupling</li> <li>Polymorphism</li> <li>Pure Fabrication</li> </ul> </li> <li>SOLID <ul> <li>Single Responsibility Principle</li> <li>Open Closed Principle</li> <li>Liskov Substitution principle</li> <li>Interface Segregation Principle</li> <li>Dependency Inversion Principle</li> </ul> </li> </ul> <p>To me this is really weird, because we're programming for mathmetical machines and not humans. We don't execute the code, machines do. Sure we as programmers spend all our lives reading code, but that's nothing in comparison how long a program runs on the end-user's machine (customer, server, whatever).</p> <p>It's even crazier to me that a huge amount of somewhat vague (not mathmetically sound) set of rules dictates correctness of a program. If you truly need the complexity an OOP language brings with it and this amount of principles to define what a correct program is, then why aren't you asking yourself if you are approaching the program from the wrong point of view?</p> <p>That's why I want to cover in my upcoming article series how to emulate various OOP features and to demonstrate the hidden cost behind it from a best-case scenario (aka without the bloated runtime an OOP language usually comes with)</p> </div> <div class="col-md-4 p-5 blog-sidebar"> <h4>About</h4> <p>Hi! I'm a Dutch software architect. When I'm not programming all day, you can find me playing S.T.A.L.K.E.R.: Call of Pripyat or D&amp;D5E / MTG with friends, reading manga / watching anime, or daydreaming. Love sake nigiri, tasty food, researching, making things work and cute things.</p> <h4>Links</h4> <ul> <li><a href="https://www.github.com/merijnhendriks">Github</a></li> <li><a href="mailto:merijn.d.hendriks@gmail.com">Email</a></li> </ul> </div> </div> </div> </body></html>