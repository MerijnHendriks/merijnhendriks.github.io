<!DOCTYPE html><html lang="en"><head> <meta charset="utf-8"> <meta name="viewport" content="width=device-width,initial-scale=1"> <meta name="description" content="My personal blog"> <meta name="author" content="Merijn Hendriks"> <title>Merijn Hendriks</title> <link rel="icon" type="image/x-icon" href="./assets/img/favicon.ico"> <link rel="stylesheet" type="text/css" href="./assets/css/bundle.css"> </head> <body> <div class="container-fluid min-vh-100 d-flex flex-column"> <div class="p-5 blog-banner"> <div class="container-fluid py-5"> <h1 class="display-5 fw-bold"><a href="./index.html">Merijn Hendriks</a></h1> <p class="col-md-8 fs-4">Programmer, Creative, Nerd</p> </div> </div> <div class="row flex-grow-1"> <div class="col-md-8 p-5" id="blog-content"><h1 id="oop-c89-thoughts">OOP-C89: Thoughts</h1> <p>To me, object-oriented programming is a bit weird. It's like trying to make many small-contained programs in a big program, or to componentize your code to the extend it's becoming lego bricks; plug and play. It's a way of programming loved by enterprises and acedemia for the modularity, protections and standarization, as well as for all the open-ended debate and research that comes with new techniques and philosophies. On the other side, very important programmers like <code>Rob Pike</code>, <code>Paul Graham</code> and <code>John Carmack</code> advocate against the usage of object-oriented design:</p> <blockquote class="blockquote blog-blockquote px-3"> <p>"object-oriented design is the roman numerals of computing." — Rob Pike</p> <p>"The object-oriented model makes it easy to build up programs by accretion. What this often means, in practice, is that it provides a structured way to write spaghetti code." — Paul Graham</p> <p>"Sometimes, the elegant implementation is just a function. Not a method. Not a class. Not a framework. Just a function." — John Carmack</p> <p>"It is not that uncommon for the cost of an abstraction to outweigh the benefit it delivers. Kill one today!" — John Carmack</p> </blockquote> <h2 id="correctness">Correctness</h2> <p>Something I wondered about is that imperative program use tuning machines to prove mathmetical corectness of a program. Functional programs can use labda calculus. Event driven languages can use pi calculus. But what about OOP? So far there is no mathmetical model which can validate the mathmetical corectness of such a program, or at least not one that I am aware of.</p> <p>Instead, OOP relies on principles and paradigms like GRASP and SOLID;</p> <ul> <li>Favor composition over inheritance</li> <li>Hollywood Principle</li> <li>Program to an Interface, not to an Implementation</li> <li>GRASP<ul> <li>Creator</li> <li>Controller</li> <li>High Cohesion</li> <li>Indirection</li> <li>Information Expert</li> <li>Low Coupling</li> <li>Polymorphism</li> <li>Pure Fabrication</li></ul></li> <li>SOLID<ul> <li>Single Responsibility Principle</li> <li>Open Closed Principle</li> <li>Liskov Substitution principle</li> <li>Interface Segregation Principle</li> <li>Dependency Inversion Principle</li></ul></li> </ul> <p>All those combined form the basis of writing a "correct" program in an OOP-based language. To me this is really weird, because we're against mathmetical machines and not humans. Sure we as programmers spend all our lives reading code, but that's nothing in comparison how long a program runs on the end-user's machine (customer, server, whatever).</p> <h2 id="oop-considered-harmful">OOP considered harmful?</h2> <p>Because of all the standarization efforts, it's much easier for enterprises to look for programmers with a specific set of skills universally understood. This in theory means there are much more job oppertunities, but in pratice it means the programmers are now turned into robots glueing components together others wrote or written by yourself.</p> <p>Okay that's quite an overstatement, but there is truth to this; businesses like to play it safe, why write it yourself if someone else did it already? There are plenty of arguments to be made in opposition to this, but usually it's not appriciated. That's why these days I just try to avoid the discussion.</p> <p>I don't think that OOP is bad on it's own, there certainly are cases where OOP <em>is</em> the best solution. However, I believe that most programmers passionate about OOP go too deep into the doctrine of adhearing to principles and paradigms, making them blind to the complexity it brings with it.</p> <p>That's why I want to cover in my upcoming article series how to emulate various OOP features, how it could utilized in C89, and to demonstrate the hidden cost behind OOP.</p></div> <div class="col-md-4 p-5 blog-sidebar"> <h4>About</h4> <p>Hi! I'm a Dutch software architect. When I'm not programming all day, you can find me playing D&amp;D5E / MTG / video games with friends, reading manga / watching anime, or daydreaming. Love sushi, salmon, researching, making things work and cute things.</p> <h4>Links</h4> <ul> <li><a href="https://www.github.com/merijnhendriks">Github</a></li> <li><a href="mailto:merijn.d.hendriks@gmail.com">Email</a></li> </ul> </div> </div> </div> </body></html>