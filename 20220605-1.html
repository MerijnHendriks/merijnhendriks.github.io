<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"> <meta name="viewport" content="width=device-width,initial-scale=1"> <meta name="author" content="Merijn Hendriks"> <meta name="description" content="My personal blog."> <title>Merijn Hendriks</title> <link rel="icon" type="image/jpeg" href="./assets/img/favicon.jpg"> <link rel="stylesheet" type="text/css" href="./assets/css/bundle.css"> </head> <body> <header class="p-5 blog-banner"> <div class="container-fluid py-5"> <h1 class="fw-bold"><a href="./index.html">lp0 on fire</a></h1> <p class="fs-4">My personal blog</p> </div> </header> <div class="container-fluid d-flex flex-column"> <div class="row flex-grow-1"> <main class="col-lg-9 p-5"> <article> <h1>Rant: Fanatical programming</h1> <p>I'm a mostly self-taught programmer, I like <em>concise</em> code: as simple, minimalistic and direct, modular, performant, portable, zero or very low dependency on external code or libraries. I like solving problems and thinking of ways to improve, to program the way in the unix philosophy, to find solutions of my own and get creative. Programming is a form of art after all.</p> <p>Most of this was lost with the advent of frameworks, package repositories, design patterns and object-oriented principles, unit tests, everything under &quot;the modern way&quot; and &quot;best practices&quot;. Scratch that, include anything related to enterprise programming standards. None of these are bad per-se, but they became bad ideas because for some reason people are <em>very</em> fanatical about them.</p> <h2>An example</h2> <p>&quot;Program to an interface, not the implementation&quot; is a good one. The idea itself isn't bad at all, but only on small scale where you know you'll have to replace systems later on. Interfaces do have a hidden cost that no one considers because they do not know the inner workings of a language. It's stupid to bind <em>everything</em> to an interface, because now you don't only have double the work to maintain but now your whole application is littered with function pointer tables. Dependency Injection frameworks to me make little sense for this reason, the cost and complexity is too high for the gain.</p> <h2>Unit testing</h2> <p>Another one is unit testing. The idea itself is great; you can make sure exceptional circumstances are tested well. But to force your full application (every single function) to be tested this way? That's a waste of everyone's time. Unit tests are not a specification for your program to follow. Otherwise people will just focus on passing a test that could be wrong because the specification is wrong. That doesn't solve your program not working as intended or being slow.</p> <h2>Package manager</h2> <p>Then there is frameworks, often employed in combination of a package manager because frameworks these days are build out of hundereds of tiny packages. That's hundereds of possible vunerabilities as <a href="https://www.mend.io/">Mend</a> reported over 1300 malicious packages being hosted on npm (node package manager), and the recent discoveries show how devastating it can be like with <code>log4j</code> in Java which was a &quot;best pratice&quot; to use.</p> <p>In addition, if the package manager service is down you can no longer obtain these packages unless their source code is hosted somewhere else.</p> <p>So far I've yet to find a real good use case for a package manager. They are there for convenience and control (of the platform). For C/C++ I just search online for the library I need and use it. This has worked for many years, so why doesn't it work anymore? I can't see why.</p> <h2>Frameworks</h2> <p>There are valid use-cases for frameworks, like for things that truly are too big to be understood by one person. A game engine and scientific frameworks are a very good example of this. Those are there out of necessity, not out of convenience. I'll specifically be adressing convenience frameworks here (eg most javascript frameworks out there like <code>express</code>, <code>vue</code> and <code>react</code>).</p> <p>These are usually bloated in functionality you rarely ever gotta use to it's full extend but still pay the price for. It's written in a generic fashion so you can be sure it's not optimized to your use-case. The worst part is that most people don't read nor understand the inner workings of the framework's code. They rely on others telling them that everything is alright and assume the framework doesn't change.</p> <p>That to me sounds like a huge security concern, creates dependency that didn't need to be there and it bred a group of programmers that can no longer write code without one nor understand what their code does exactly.</p> <p>Some programmers argue that &quot;if the framework broke then it's broken for everyone else too and thus the problem of the framework maintainer, not me&quot; but this is not the case. If a business runs on that framework that breaks, now you have to deal with the customers and lose money over it. Worst of all, it didn't have to be this way if you rolled your own code instead.</p> </article> </main> <aside class="col-lg-3 blog-sidebar"> <div class="p-5"> <h4>About</h4> <p>Hi! My name is Merijn Hendriks and I'm a Dutch programmer with a love for hamburgers and sake nigiri. When I'm not programming all day, you can find me reading manga, playing S.T.A.L.K.E.R.: Call of Pripyat or D&amp;D5E / MTG with friends.</p> <h4>Links</h4> <ul> <li><a href="https://www.github.com/merijnhendriks">Github</a></li><li><a href="mailto:me@nohurry.moe">Email</a></li><li><a href="https://nohurry.moe/feed.rss">RSS</a></li> </ul> </div> </aside> </div> </div> </body> </html>