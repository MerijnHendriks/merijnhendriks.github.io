# C89-DP: prototype

Apparently the goal of this pattern is to cache costly objects and clone them
instead of requesting them again. I've never used this before, so it should be
a nice challenge!

## IClonable

This is what all clonable classes will be implementing.

```c
typedef struct IClonable IClonable;

struct IClonable
{
    void (*clone)(IClonable* self, IClonable* other);
};
```

## Something clonable

We'll be re-using `Foo` from `C89-OOP: Class` but with a minor twist; it's
going to have `IClonable` implemented.

```c
typedef struct Foo Foo;

struct Foo
{
    IClonable* iclonable;
    int x;
};

void Foo_clone(IClonable* self, IClonable* other)
{
    Foo* a = (Foo*)self;
    Foo* b = (Foo*)other;
    b->x = a->x;
}

void Foo_ctor(Foo* self, int x)
{
    static IClonable iclonable = {
        Foo_clone
    };

    self->iclonable = &iclonable;
    self->x = x;
}
```

`Foo_clone` is where the magic happens. We just copy the values over to the
other instance.

## Cache

Normally you would make a list or array for this, but in our case having an
indexed static instance is good enough. I use an array of ints (C89 doesn't
have a `bool` type build-in) to keep track of which values are initialized.

```c
#define ISLOADED_LENGTH 1

enum CacheIds
{
    LOAD_FOO = 0
};

static int isLoaded[ISLOADED_LENGTH] = { 0 };

void Cache_get(IClonable* instance, int id)
{
    static Foo cache_foo = { 0 };

    switch (id)
    {
        case LOAD_FOO:
        {
            if (!isLoaded[LOAD_FOO])
            {
                Foo_ctor(&foo, 1);
                isLoaded[LOAD_FOO] = 1;
            }

            foo.iclonable->clone((IClonable*)&foo, instance);
            return;
        }
    }
}
```

The idea shares alot with the Factory pattern discussed before in the article
`C89-DP: Factory`. But instead of running the constructor, we are cloning the
values of `Foo` into another instance of `Foo`.

## Usage

As simple as it gets:

```c
Foo foo;
int val;

Cache_get((IClonable*)&foo, LOAD_FOO);
val = foo.x;
```

## Conclusion

It just works. It takes a bit of setup, but its nice that it was doable.
