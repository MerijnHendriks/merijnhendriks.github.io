# C89-OOP: Type system, simplified

One thing I was dissatisfied with was the boilerplate code required to make the
type system work. Since much of that code is shared, there I wondered if there
was a way to simplify it, and I finally found it. Not only did I get rid of
duplication, it also allowed for further simplification of the type system
overall.

It is still worthwhile to use the other if you need to extend it past the bare
minimum required for a type system.

## Type structure

This is where the most drastic change was made.

```c
typedef struct Type Type;

struct Type
{
    int id;
};

void Type_ctor(Type* self, int* typeId)
{
    static int id = 0;

    if (*typeId == 0)
    {
        *typeId = ++id;
    }

    self->id = *typeId;
}
```

`Type_ctor` is now the combination of `Type_setId` and `Foo_setTypeId`. It now
describes how the type structure should be modified instead of just generating
an id. This allows for more code reuse and keeping code related to the type
system in the same place.

In addition, changed the function pointer to plain data instead to make it
easier to keep track of what's going on.

## Base type

The biggest change here is stripping code.

```c
typedef struct Foo Foo;

struct Foo
{
    Type type;
    int x;
};

void Foo_ctor(Foo* self, int x)
{
    static int typeId = 0;

    Type_ctor((Type*)self, &typeId);
    self->x = x;
}
```

Instead of storing the `typeId` _and_ the VMT into the static register, now
only `typeId` needs to be stored. All of `Foo`'s `typeId` generation code was
no longer needed and thus removed, and is instead handled by `Type_ctor`.

## Derived type

Just like with `Foo`, most of what I did was stipping

```c
typedef struct Bar Bar;

struct Bar
{
    Foo base;
    int y;
};

void Bar_ctor(Bar* self, int x, int y)
{
    static int typeId = 0;

    Foo_ctor((Foo*)self, x);
    Type_ctor((Type*)self, &typeId);
    self->y = y;
}
```

Much simpler. All old code could be removed and `Type_setId` can be used here
as well for initialization of the type.

## Usage

The only downside to this approach is that you need to make an instance of the
class you want to compare against, opposed to just a function call.

```c
Bar bar;
Foo* foo;
Type* type;
int isBarType;

Bar_ctor(&bar, 1, 2);
type = (Type*)&bar;
foo = (Foo*)&bar;
isBarType = foo->type->id == type->id;
```

## Conclusion

Overall a simpler system with less code and overall runtime costs, at the
expense of cost for making comparisons against a single type a bit more
complicated.

I would still recommend the other type system in case you need to extend the
type system further and/or if you have to compare against a single type often.
