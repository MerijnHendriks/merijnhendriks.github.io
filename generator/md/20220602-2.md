# C89-OOP: Type system

Downcasting and upcasting types can be hard because it's easy to lose track of
which type what instance was. Since in most OOP languages we have a type system
that helps with determinating the type at runtime, I thought it was a nice
challenge to emulate this in C.

Strap yourself in, get a nice cup of coffee and get comfortable. This article
is gonna be a long one with _a lot_ of technical information.

## Design

I found quite some research papers online on the topic, but I'm not smart
enough to understand any of it so I wrote my own implementation without using
any of the available papers for reference.

My implementation is designed to be as simple and portable as possible, but it
is not as feature-rich as a full-blown type system found in C# or Java. My
objective here is to solve a specific problem, not to be feature-complete.

The goal is to map user types to an identifier, which can be accessed from the
class instance and is to be used for comparison of types. While this can be
done statically in C, resolving the type identifiers might become difficult due
to types being mapped to the same identifier. This is why I opted to resolving
the type identifiers at runtime. This does mean that there is a possibly that
the identifier is different between runs, and that one cannot depend on this
value being the same.

One could make a large list and point to an entry of the list for the type, but
I judged that this would take too much memory on embedded boards. Instead I
opted for having a source-private variable in every source containing a class
using this functionality.

## Implementation

For an overview, we can divide into 3 parts:

- Type core: consists of the `Type` VMT, a way of generating new identifiers,
  and a function shared with all base types.
- Base type: embeds the `Type` VMT and binding the initial type information to
  it.
- Derived type: modifies the embedded `Type` VMT by overriding the type
  information with it's own.

The type core we only have to write once, but the others we have to implement
by hand for each type.

### Type

There really isn't anything overly complicated here.

```c
typedef struct Type Type;

struct Type
{
    int (*getId)(void);
    int (*isDerivedOf)(Type* type);
};

int Type_getNewId()
{
    static int id = 0;
    return ++id;
}

int Type_isBaseDerived(Type* type)
{
    return 0;
}
```

To break this down:

```c
typedef struct Type Type;

struct Type
{
    int (*getId)(void);
    int (*isDerivedOf)(Type* type);
};
```

We make a `Type` VMT to get the instance's type and to compare if the type is
derived from another type on runtime.

```c
int Type_getNewId()
{
    static int id = 0;
    return ++id;
}
```

This is all the code we use for generating new type id's. I really like the
simplicity of the solution.

```c
int Type_isBaseDerived(Type* type)
{
    return 0;
}
```

This little function is important later on (when I cover the base type) so keep
it in mind for now.

### Base type

I've modified `Foo` from `C89-OOP: Class` to demonstrate the new things we need
to add in. Quite a bit of code has been added:

```c
typedef struct Foo Foo;

struct Foo
{
    Type* type;
    int x;
};

int Foo_getTypeId()
{
    static int id = 0;

    if (id == 0)
    {
        id = Type_getNewId();
    }

    return id;
}

void Foo_ctor(Foo* self, int x)
{
    static Type type_foo = {
        Foo_getTypeId,
        Type_isBaseDerived
    };

    self->type = &type_foo;
    self->x = x;
}
```

To break it down:

```c
int Foo_getTypeId()
{
    static int id = 0;

    if (id == 0)
    {
        id = Type_getNewId();
    }

    return id;
}
```

This is where the type identifier of `Foo` is generated and assigned. The
`Foo_getType` function is exposed outside to allow derived classes to use
it for comparison later.

```c
void Foo_ctor(Foo* self, int x)
{
    static Type type_foo = {
        Foo_getTypeId,
        Type_isBaseDerived
    };

    self->type = &type_foo;
    self->x = x;
}
```

Here we create the type information and assign it. Notice the
`Type_isDerivedType` function being used there? This is the function that allow
base types to always return false for derived type comparisons.

### Derived type

This is the modified `Bar` class from `C89-OOP: Single Inheritance`. Like with
`Foo`, quite a bit of code has been added.

```c
typedef struct Bar Bar;

struct Bar
{
    Foo base;
    int y;
};

static int Bar_isDerivedOf(Type* type)
{
    return type->getId() == Foo_getTypeId();
}

int Bar_getTypeId()
{
    static int id = 0;

    if (id == 0)
    {
        id = Type_getNewId();
    }

    return id;
}

void Bar_ctor(Bar* self, int x, int y)
{
    static Type type_bar = {
        Bar_getTypeId,
        Bar_isDerivedOf
    };

    Foo_ctor(&self->base, x);
    self->base.type = &type_bar;
    self->y = y;
}
```

To break it down:

```c
static int Bar_isDerivedOf(Type* type)
{
    return type->getId() == Foo_getTypeId();
}
```

This is why it's important to expose the `Foo_getTypeId` function. We use it to
see if the passed type is indeed `Foo` or another type that `Bar` is derived
of.

```c
void Bar_ctor(Bar* self, int x, int y)
{
    static Type type_bar = {
        Bar_getTypeId,
        Bar_isDerivedOf
    };

    Foo_ctor(&self->base, x);
    self->base.type = &type_bar;
    self->y = y;
}
```

Unlike `Foo`, we change the `Type` to match `Bar` instead of adding a new
`Type` field into the class. This way if we cast `Bar` to `Foo` it would
still report it to be `Bar`. This is the same behaviour as in C#.

## Usage

The code isn't very clean, but it does illustrate how it works well:

```c
Bar bar;
Foo* foo;
int isBarType;

Bar_ctor(&bar, 1, 2);
foo = (Foo*)&bar;
isBarType = foo->type->getId() == Bar_getTypeId();
```

To compare the types of two instances for equality:

```c
int Type_equals(Type* typeA, Type* typeB)
{
    return typeA->getId() == typeB->getId();
}

int main()
{
    Foo foo;
    Bar bar;
    int isBarType;

    Foo_ctor(&foo, 1);
    Bar_ctor(&bar, 1, 2);
    isBarType = Type_equals((Type*)&foo, (Type*)&bar);

    return 0;
}
```

## Conclusion

You now learned how to roll your own primitive type system. Even if this one
isn't very complex, it is still quite a handful to write manually. It's not
something you would need often, but when you need it you're thankful that you
have it in an OOP language.
