# C89-OOP: Type system

Downcasting and upcasting types can be hard because it's easy to lose track of
which type what instance was. Since in most OOP languages we have a type system
that helps with determinating the type at runtime, I thought it was a nice
challenge to emulate this in C.

Strap yourself in, get a nice cup of coffee and get comfortable. This article
is gonna be a long one with _a lot_ of technical information.

## Design

I found quite some research papers online on the topic, but I'm not smart
enough to understand any of it so I wrote my own implementation without using
any of the available papers for reference.

My implementation is designed to be as simple and portable as possible, but it
is not as feature-rich as a full-blown type system found in C++, C# or Java. My
objective here is to solve a specific problem, not to be feature-complete.

The goal is to map user types to an identifier, which can be accessed from the
class instance and is to be used for comparison of types. While this can be
done statically in C, resolving the type identifiers might become difficult due
to types being mapped to the same identifier. This is why I opted to resolving
the type identifiers at runtime. This does mean that there is a possibly that
the identifier is different between runs, and that one cannot depend on this
value being the same.

One could make a large list and point to an entry of the list for the type, but
I judged that this would take too much memory on embedded boards. Instead I
opted for static VMT instances.

I left out a couple of functions that usually come with a type system, such as
`getTypeName`, `isSubclassOf`, `getHashCode` and more. I judged that those are
not an absolute requirement for the type system to work, and that programmers
could implement these themselves if it becomes necessary.

## Implementation

For an overview, we can divide into 3 parts:

- Type core: consists of the `Type` VMT, a way of generating new identifiers,
  and a function shared with all base types.
- Base type: embeds the `Type` VMT and binding the initial type information to
  it.
- Derived type: modifies the embedded `Type` VMT by overriding the type
  information with it's own.

The type core only has to write once, but all type information needs to be
implemented by hand. The implementation is very simple and straightforward,
which helps with keeping complexity down in an already complicated paradigm.

### Type

```c
typedef struct Type Type;

struct Type
{
    int (*getId)(void);
};

int Type_getNewId()
{
    static int id = 0;
    return ++id;
}
```

We make a `Type` VMT which contains a pointer to the function returning the
instance's type id. The code for generating the new id speaks for itself.

### Base type

I've modified `Foo` from `C89-OOP: Class` to demonstrate the new things we need
to add in:

```c
typedef struct Foo Foo;

struct Foo
{
    Type* type;
    int x;
};

int Foo_getTypeId()
{
    static int id = 0;

    if (id == 0)
    {
        id = Type_getNewId();
    }

    return id;
}

void Foo_ctor(Foo* self, int x)
{
    static Type type_foo = {
        Foo_getTypeId
    };

    self->type = &type_foo;
    self->x = x;
}
```

`Foo_getTypeId` generates a new id if it doesn't have one yet, and returns this
id. In `Foo_ctor` we create the static instance of `Foo`'s type information and
assign it to all instances of `Foo`.

### Derived type

This is the modified `Bar` class from `C89-OOP: Single Inheritance`. Like with
`Foo`, quite a bit of code has been added.

```c
typedef struct Bar Bar;

struct Bar
{
    Foo base;
    int y;
};

int Bar_getTypeId()
{
    static int id = 0;

    if (id == 0)
    {
        id = Type_getNewId();
    }

    return id;
}

void Bar_ctor(Bar* self, int x, int y)
{
    static Type type_bar = {
        Bar_getTypeId
    };

    Foo_ctor(&self->base, x);
    self->base.type = &type_bar;
    self->y = y;
}
```

Unlike `Foo`, we change the `Type` to match `Bar` in the constructor. This way
if we cast `Bar` to `Foo` it would still report it to be `Bar`. This is the
same behaviour as in C#.

## Usage

The code isn't very clean, but it does illustrate how it works well:

```c
Bar bar;
Foo* foo;
int isBarType;

Bar_ctor(&bar, 1, 2);
foo = (Foo*)&bar;
isBarType = foo->type->getId() == Bar_getTypeId();
```

To compare the types of two instances for equality:

```c
Foo foo;
Bar bar;
int isBarType;

Foo_ctor(&foo, 1);
Bar_ctor(&bar, 1, 2);
isBarType = foo.type->getId() == bar.base.type->getId();
```

## Conclusion

You now learned how to roll your own primitive type system. Even if this one
isn't very complex, it is still quite a handful to write manually. It's not
something you would need often, but when you need it you're thankful that you
have it in an OOP language.
