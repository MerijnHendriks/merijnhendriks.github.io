# OOP-C89: Casting

In most OOP languages it's possible to cast `base <-> derived`. A quick example
of what I mean:

```csharp
Bar bar = new Bar();
Foo a = (Foo)bar;
Bar b = (Bar)a;
```

In C89, the same is possible through pointer magic:

```c
Bar bar;
Foo a;
Bar b;

Bar_ctor(&bar, 1, 2);
a = (*(Foo*)&bar);
b = (*(Bar*)&a);
```

When downcasting, ensure that the class you're downcasting from is indeed of
this type, otherwise you'll get random values from memory addresses and
possibly a `segmentation fault` error.

Remember when I said it was important to have the `base` member first? The
trick from above only works because of how memory alignment and padding rules
work for structs;

> "A pointer to a structure object, suitably converted, points to its initial
> member. There may be unnamed padding within a structure object, but not at
> its beginning" â€” WG14/N1256 Section 6.7.2.1.13

This means that alignment is kept for the first member of a struct, which in
return allows us to cast.

If we have have this scenario:

```c
typedef struct A A;
typedef struct B B;
typedef struct C C;
typedef struct D D;

struct A
{
    int val;
};

struct B
{
    A base;
    int val;
};

struct C
{
    A base;
    int val;
};

struct D
{
    B baseB;
    C baseC;
    int val;
};
```

...and cast this like so:

```c
C c;
D d;
C foo;

C_ctor(&c, 1, 2);
d = (*(D*)&c);
foo = (*(C*)&d);
```

Then it will cast correctly `C` -> `D` -> `C` (tested on Clang 7+ and GCC 4+).
I haven't fully explored yet if it would work on heap allocated structs or used
this extensively as I frankly speaking never had to.

## Conclusion

You now know how to upcast and downcast structs in C89. In the next article
I'll discuss polymorphism and optimization techniques for it.
