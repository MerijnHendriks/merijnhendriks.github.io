var crypto = require("crypto");
var fs = require("fs");
var path = require("path");
var { JSDOM } = require("jsdom");
var MarkdownIt = require("markdown-it");
var mdmedia = require("markdown-it-html5-media");
var mdprism = require("markdown-it-prism");
var mdtitle = require("markdown-it-title");
var CleanCSS = require("clean-css");
var htmlMinifier = require("html-minifier");

var cssMinifier = new CleanCSS();
var htmlMinifyOptions = {
  "collapseInlineTagWhitespace": true,
  "collapseWhitespace": true,
  "conservativeCollapse": true,
  "includeAutoGeneratedTags": false,
  "minifyCSS": true,
  "removeComments": true,
  "removeEmptyAttributes": true,
  "removeEmptyElements": true,
  "removeRedundantAttributes": true
};

var config = {};
var hashdb = {};

function writeFile(filepath, data) {
  if (!fs.existsSync(filepath)) {
    // create missing directories recursively
    var target = filepath.substr(0, filepath.lastIndexOf("/"));
    fs.mkdirSync(target, { "recursive": true });
  }

  fs.writeFileSync(filepath, data);
}

function readFile(filepath) {
  return fs.readFileSync(filepath).toString();
}

function getFiles(filepath) {
  var files = fs.readdirSync(filepath);
  var i = files.length;

  while (i--) {
    var item = path.join(filepath, files[i]);
    if (!fs.statSync(item).isFile()) {
      files.splice(i, 1);
    }
  }

  return files;
}

function getFilename(filepath) {
  return filepath.split('.').slice(0, -1).join('.');
}

function jsonPrettify(o) {
  return JSON.stringify(o, null, 4)
}

function mdToHtml(markdown) {
  var md = new MarkdownIt({ "html": true })
    .use(mdmedia.html5Media)
    .use(mdprism, { "defaultLanguage": "txt" });
  return md.render(markdown);
}

function getMdTitle(markdown) {
  var result = {};
  var md = new MarkdownIt({ "html": true })
    .use(mdtitle, { "level": 1, "excerpt": 1});

  md.render(markdown, result);
  return result;
}

function getLinks() {
  var html = "";
  var links = config.page.links;
  var keys = Object.keys(links);

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    html += '<li><a href="' + links[key] + '">' + key + '</a></li>';
  }

  return html;
}

function generatePage(filename) {
  console.log("Generating page: " + filename);
  var html = readFile(config.input.templates + "page.html");

  // replace template strings
  html = html.replaceAll("<!-- $author -->", config.general.author);
  html = html.replaceAll("<!-- $description -->", config.general.description);
  html = html.replaceAll("<!-- $banner -->", config.page.banner);
  html = html.replaceAll("<!-- $about -->", config.page.about);
  html = html.replaceAll("<!-- $links -->", getLinks());

  // load document
  var dom = new JSDOM(html);
  var document = dom.window.document;

  // generate markdown
  var markdown = readFile(config.input.md + filename + ".md");
  var element = document.getElementsByClassName("blog-content")[0];
  element.innerHTML = mdToHtml(markdown);

  // add doctype to prevent quicks mode warning
  var doctypefix = "<!DOCTYPE html>" + document.documentElement.outerHTML;

  // save result minified
  var result = htmlMinifier.minify(doctypefix, htmlMinifyOptions);
  writeFile(config.output.html + filename + ".html", result);
}

function didHashChange(filepath) {
  var buffer = fs.readFileSync(filepath);
  var hash = crypto.createHash("sha256");
  hash.update(buffer);
  var result = hash.digest("hex");

  if (!hashdb[filepath] || hashdb[filepath] !== result) {
    hashdb[filepath] = result;
    return true;
  }

  return false;
}

function getFeedItem(file, title, description) {
  return "<item><link>https://" + config.rss.host + "/" + file + "</link>"
    + "<title>" + title + "</title>"
    + "<description>" + description + "</description></item>";
}

function shouldSkipFeed(filename) {
  for (var i = 0; i < config.rss.skip.length; i++) {
    if (filename == config.rss.skip[i]) {
      return true;
    }
  }

  return false;
}

function generateFeed() {
  console.log("Generating file: rss feed");

  var files = getFiles(config.input.md);
  var feed = readFile(config.input.templates + "feed.rss");

  // generate feed
  feed = feed.replaceAll("<!-- $host -->", config.rss.host);
  feed = feed.replaceAll("<!-- $description -->", config.general.description);

  var items = "";
  for (var i = 0; i < files.length; i++) {
    var filename = getFilename(files[i]);

    if (shouldSkipFeed(filename)) {
      continue;
    }

    var markdown = readFile(config.input.md + filename + ".md");
    var info = getMdTitle(markdown);
    var description = info.excerpt[0]
      .slice(0, config.rss.introsize)
      .trim()
      + "...";
    items += getFeedItem(filename + ".html", info.title, description);
  }

  feed = feed.replaceAll("<!-- $items -->", items);
  writeFile(config.output.rss, feed);
}

function generateAllPages() {
  var files = getFiles(config.input.md);

  // generate pages
  for (var i = 0; i < files.length; i++) {
    var filename = getFilename(files[i]);

    if (didHashChange(config.input.md + files[i])) {
      generatePage(filename);
    } else {
      console.log("Skip generating page: " + filename);
    }
  }
}

function generateCssBundle() {
  var files = getFiles(config.input.css);
  var changed = 0;

  for (var i = 0; i < files.length; i++) {
    // set correct path
    files[i] = config.input.css + files[i];

    // check if file changed
    if (didHashChange(files[i])) {
      changed++;
    }
  }

  if (changed === 0) {
    console.log("Skip generating file: css bundle");
    return;
  }

  console.log("Generating file: css bundle");
  console.log(files);
  var minified = cssMinifier.minify(files);
  writeFile(config.output.css, minified.styles);
}

function main() {
  // load config
  config = JSON.parse(readFile("./assets/config.json"));

  // load hashdb
  hashdb = fs.existsSync(config.input.hashdb)
    ? JSON.parse(readFile(config.input.hashdb))
    : {};

  // generate files
  generateFeed();
  generateAllPages();
  generateCssBundle();

  // save hashdb
  writeFile(config.input.hashdb, jsonPrettify(hashdb));
}

main();
