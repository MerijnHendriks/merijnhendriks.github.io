<!DOCTYPE html><html lang="en"><head> <meta charset="utf-8"> <meta name="viewport" content="width=device-width,initial-scale=1"> <meta name="description" content="My personal blog"> <meta name="author" content="Merijn Hendriks"> <title>Merijn Hendriks</title> <link rel="icon" type="image/x-icon" href="./assets/img/favicon.ico"> <link rel="stylesheet" type="text/css" href="./assets/css/bundle.css"> </head> <body> <div class="container-fluid min-vh-100 d-flex flex-column"> <div class="p-5 blog-banner"> <div class="container-fluid py-5"> <h1 class="display-5 fw-bold"><a href="./index.html">Merijn Hendriks</a></h1> <p class="col-md-8 fs-4">Programmer, Creative, Nerd</p> </div> </div> <div class="row flex-grow-1"> <div class="col-md-8 p-5" id="blog-content"><h1 id="oop-c89-casting">OOP-C89: Casting</h1> <p>In most OOP languages it's possible to cast <code>base &lt;-&gt; derived</code>. A quick example of what I mean:</p> <pre class="language-csharp" tabindex="0"><code><span class="token class-name">Bar</span> bar <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Foo</span> a <span class="token operator">=</span> <span class="token punctuation">(</span>Foo<span class="token punctuation">)</span>bar<span class="token punctuation">;</span>
<span class="token class-name">Bar</span> b <span class="token operator">=</span> <span class="token punctuation">(</span>Bar<span class="token punctuation">)</span>a<span class="token punctuation">;</span>
</code></pre> <p>In C89, the same is possible through pointer magic:</p> <pre class="language-c" tabindex="0"><code>Bar bar<span class="token punctuation">;</span>
Foo a<span class="token punctuation">;</span>
Bar b<span class="token punctuation">;</span>

<span class="token function">Bar_ctor</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>bar<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
a <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>Foo<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>bar<span class="token punctuation">)</span><span class="token punctuation">;</span>
b <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>Bar<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <p>When downcasting, ensure that the class you're downcasting from is indeed of this type, otherwise you'll get random values from memory addresses and possibly a <code>segmentation fault</code> error.</p> <p>Remember when I said it was important to have the <code>base</code> member first? The trick from above only works because of how memory alignment and padding rules work for structs;</p> <blockquote class="blockquote blog-blockquote px-3"> <p>"A pointer to a structure object, suitably converted, points to its initial member. There may be unnamed padding within a structure object, but not at its beginning" — WG14/N1256 Section 6.7.2.1.13</p> </blockquote> <p>This means that alignment is kept for the first member of a struct, which in return allows us to cast.</p> <p>If we have have this scenario:</p> <pre class="language-c" tabindex="0"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">A</span> A<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">D</span> D<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">A</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> val<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">B</span>
<span class="token punctuation">{</span>
    A base<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <p>…and cast this like so:</p> <pre class="language-c" tabindex="0"><code>B b<span class="token punctuation">;</span>
A<span class="token operator">*</span> a<span class="token punctuation">;</span>

<span class="token function">B_ctor</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>b<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
a <span class="token operator">=</span> <span class="token punctuation">(</span>A<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>b<span class="token punctuation">;</span>
b <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>B<span class="token operator">*</span><span class="token punctuation">)</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <p>…or cast this like so:</p> <pre class="language-c" tabindex="0"><code>B b<span class="token punctuation">;</span>
A<span class="token operator">*</span> a<span class="token punctuation">;</span>
B<span class="token operator">*</span> c<span class="token punctuation">;</span>

<span class="token function">B_ctor</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>b<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
a <span class="token operator">=</span> <span class="token punctuation">(</span>A<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>b<span class="token punctuation">;</span>
c <span class="token operator">=</span> <span class="token punctuation">(</span>B<span class="token operator">*</span><span class="token punctuation">)</span>a<span class="token punctuation">;</span>
</code></pre> <p>Then it will cast correctly <code>B</code> -&gt; <code>A</code> -&gt; <code>B</code> (tested on Clang 7+ and GCC 4+).</p> <h2 id="side-effects">Side effects</h2> <p>There is however one thing to keep in mind; When downcasting from an upcast using pointer reference cast, pointer types lose their reference, resulting in a <code>segfault</code> or accessing in random memory.</p> <pre class="language-c" tabindex="0"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">A</span> A<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">D</span> D<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">A</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> val<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">B</span>
<span class="token punctuation">{</span>
    A baseA<span class="token punctuation">;</span>
    A<span class="token operator">*</span> virtA<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">B_ctor</span><span class="token punctuation">(</span>B<span class="token operator">*</span> self<span class="token punctuation">,</span> <span class="token keyword">int</span> a<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    self<span class="token operator">-&gt;</span>baseA<span class="token punctuation">.</span>val <span class="token operator">=</span> a<span class="token punctuation">;</span>
    self<span class="token operator">-&gt;</span>virtA <span class="token operator">=</span> <span class="token operator">&amp;</span>self<span class="token operator">-&gt;</span>baseA<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <pre class="language-c" tabindex="0"><code>B b<span class="token punctuation">;</span>
A a<span class="token punctuation">;</span>

<span class="token function">B_ctor</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>b<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
a <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>A<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
b <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>B<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <p>For example, accessing <code>foo.virtC-&gt;val</code> would result in a segfault, but accessing <code>d.virtC-&gt;val</code> would not.</p> <h2 id="conclusion">Conclusion</h2> <p>You now know how to upcast and downcast structs in C89, as well as the possible side effects from doing this. In the next article I'll discuss inheritance through interfaces.</p></div> <div class="col-md-4 p-5 blog-sidebar"> <h4>About</h4> <p>Hi! I'm a Dutch software architect. When I'm not programming all day, you can find me playing D&amp;D5E / MTG / video games with friends, reading manga / watching anime, or daydreaming. Love Sake Nigiri, researching, making things work and cute things.</p> <h4>Links</h4> <ul> <li><a href="https://www.github.com/merijnhendriks">Github</a></li> <li><a href="mailto:merijn.d.hendriks@gmail.com">Email</a></li> </ul> </div> </div> </div> </body></html>