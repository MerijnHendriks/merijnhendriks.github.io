<!DOCTYPE html><html lang="en"> <head> <meta charset="utf-8"> <meta name="viewport" content="width=device-width,initial-scale=1"> <meta name="author" content="Merijn Hendriks"> <title>Merijn Hendriks</title> <link rel="icon" type="image/x-icon" href="./assets/img/favicon.ico"> <link rel="stylesheet" type="text/css" href="./assets/css/bundle.css"> </head> <body> <div class="container-fluid min-vh-100 d-flex flex-column"> <header class="p-5 blog-banner"> <div class="container-fluid py-5"> <h1 class="display-5 fw-bold"><a href="./index.html">Merijn Hendriks</a></h1> <p class="col-md-8 fs-4">Programmer, Creative, Nerd</p> </div> </header> <div class="row flex-grow-1"> <article class="col-md-8 p-5" id="blog-content"><h1>C89-OOP: Casting</h1> <p>In most OOP languages it's possible to cast <code>base &lt;-&gt; derived</code>. A quick example of what I mean:</p> <pre class="language-csharp"><code class="language-csharp"><span class="token class-name">Bar</span> bar <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Foo</span> a <span class="token operator">=</span> <span class="token punctuation">(</span>Foo<span class="token punctuation">)</span>bar<span class="token punctuation">;</span>
<span class="token class-name">Bar</span> b <span class="token operator">=</span> <span class="token punctuation">(</span>Bar<span class="token punctuation">)</span>a<span class="token punctuation">;</span>
</code></pre> <p>In C89, the same is possible through pointer magic:</p> <pre class="language-c"><code class="language-c">Bar bar<span class="token punctuation">;</span>
Foo<span class="token operator">*</span> a<span class="token punctuation">;</span>
Bar b<span class="token punctuation">;</span>

<span class="token function">Bar_ctor</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>bar<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
a <span class="token operator">=</span> <span class="token punctuation">(</span>Foo<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>bar<span class="token punctuation">)</span><span class="token punctuation">;</span>
b <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>Bar<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <p>Remember when I said it was important to have the <code>base</code> member first? The trick from above only works because of how memory alignment and padding rules work for structs;</p> <blockquote class="blockquote blog-blockquote px-3"> <p>"A pointer to a structure object, suitably converted, points to its initial member. There may be unnamed padding within a structure object, but not at its beginning" â€” WG14/N1256 Section 6.7.2.1.13</p> </blockquote> <p>This means that alignment is kept for the first member of a struct, which in return allows us to cast.</p> <p>Meaning it will cast correctly <code>Bar</code> -&gt; <code>Foo</code> -&gt; <code>Bar</code> (tested on Clang 7+ and GCC 4+).</p> <h2>Side effects</h2> <p>When downcasting, ensure that the class you're downcasting from is indeed of this type, otherwise you'll get random values from memory addresses and possibly a <code>segfault</code>.</p> <p>When downcasting from an upcast using pointer reference cast and then accessing a pointer member will also result into a <code>segfault</code>.</p> <pre class="language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">A</span> A<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">B</span> B<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">A</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> val<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">B</span>
<span class="token punctuation">{</span>
    A baseA<span class="token punctuation">;</span>
    A<span class="token operator">*</span> virtA<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">B_ctor</span><span class="token punctuation">(</span>B<span class="token operator">*</span> self<span class="token punctuation">,</span> <span class="token keyword">int</span> a<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    self<span class="token operator">-&gt;</span>baseA<span class="token punctuation">.</span>val <span class="token operator">=</span> a<span class="token punctuation">;</span>
    self<span class="token operator">-&gt;</span>virtA <span class="token operator">=</span> <span class="token operator">&amp;</span>self<span class="token operator">-&gt;</span>baseA<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <pre class="language-c"><code class="language-c">B b<span class="token punctuation">;</span>
A a<span class="token punctuation">;</span>

<span class="token function">B_ctor</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>b<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
a <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>A<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
b <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>B<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <p>For example, accessing <code>b.virtA-&gt;val</code> would result in a <code>segfault</code>, but accessing <code>b.virtA-&gt;val</code> would not.</p> <h2>Conclusion</h2> <p>You now know how to upcast and downcast structs in C89, as well as the possible side effects from doing this. In the next article I'll discuss inheritance through interfaces.</p> </article> <aside class="col-md-4 p-5 blog-sidebar"> <h4>About</h4> <p>Hi! I'm a Dutch programmer with a love for hamburgers and sake nigiri. When I'm not programming all day, you can find me reading manga, playing S.T.A.L.K.E.R.: Call of Pripyat or D&amp;D5E / MTG with friends.</p> <h4>Links</h4> <ul> <li><a href="https://www.github.com/merijnhendriks">Github</a></li> <li><a href="mailto:merijn.d.hendriks@gmail.com">Email</a></li> </ul> </aside> </div> </div> </body> </html>